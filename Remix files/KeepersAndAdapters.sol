// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ChainlinkClient.sol";
import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";

contract KeepersAndAdapters is ChainlinkClient, KeeperCompatibleInterface {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    uint256 private counter;

    address private oracle;
    bytes32 private jobId;
    uint256 private fee;

    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    constructor() {
        setPublicChainlinkToken();
        oracle = oracle_address;
        jobId = "job_id";
        fee = 0; // (Varies by network and job)
        interval = 1 minutes;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        lastTimeStamp = block.timestamp;
        counter = counter + 1;
        requestVolumeData();
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        if (counter % 2 == 0) {
            request.add("lat", "50");
            request.add("lon", "50");
        } else {
            request.add("lat", "0");
            request.add("lon", "0");
        }

        // Sends the request
        return sendChainlinkRequestTo(oracle, request, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _volume)
        public
        recordChainlinkFulfillment(_requestId)
    {
        volume = _volume;
    }

    // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
}
